import e from"crypto-es";function t(t){let r=new Uint8Array(t,0,t.byteLength),n=[],i=r.length;for(let e=0;e<i;e+=1)n[e>>>2]|=(255&r[e])<<24-e%4*8;return e.lib.WordArray.create(n,i)}function r(e){for(var t=e.words,r=e.sigBytes,n=new ArrayBuffer(r),i=new Uint8Array(n),o=0;o<r;o++)i[o]=t[o>>>2]>>>24-o%4*8&255;return n}function n(e,t,r="application/octet-stream"){const n=new Blob([e],{type:r});return new File([n],t,{type:r})}function i(e){const t=e.lastIndexOf(".");return-1===t||0===t?e:e.substring(0,t)}const o=1635018061;new TextEncoder;const a=(n,i,a)=>{const c=new DataView(n,12).getUint32(0,!0),s=n.slice(0,c+12+8);let l=t(s);const y=e.enc.Utf8.parse(i),f=e.enc.Utf8.parse(a);var w=r(e.AES.encrypt(l,y,{iv:f,mode:e.mode.CBC,padding:e.pad.ZeroPadding}).ciphertext),d=new Uint8Array(w);let g=w.byteLength,h=new ArrayBuffer(12),u=new DataView(h);u.setUint32(0,o,!0),u.setUint32(4,1,!0),u.setUint32(8,g,!0);const A=new Uint8Array(h);let U=new Uint8Array(A.length+d.length);U.set(A,0),U.set(d,A.length);let p=n.slice(s.byteLength,n.byteLength),m=new Uint8Array(U),b=new Uint8Array(p),B=new Uint8Array(m.length+b.length);return B.set(m,0),B.set(b,m.length),B};class c{static EncryptionFromUrlModelToFileAsync(e,t,r){return new Promise(((o,c)=>{fetch(e).then((e=>e.arrayBuffer())).then((c=>{if(c instanceof ArrayBuffer){let s=n(a(c,t,r),`${i(e)}.mta`);o(s)}else console.error("错误glb文件",e)})).catch((e=>{console.error("enc失败,",e)}))}))}static EncryptionFromFileModelToFileAsync(e,t,r){return new Promise(((o,c)=>{let s=new FileReader;s.onload=()=>{if(s.result instanceof ArrayBuffer)try{let c=n(a(s.result,t,r),`${i(e.name)}.mta`);o(c)}catch(e){console.error("enc文件错误",e)}},s.onerror=function(){c(s.error)},s.readAsArrayBuffer(e)}))}static DecryptFromUrlModelToFileAsync(a,c,s){return new Promise(((l,y)=>{fetch(a).then((e=>e.arrayBuffer())).then((y=>{if(y instanceof ArrayBuffer){let f=((n,i,a)=>{let c=n.slice(0,12),s=new Uint8Array(c.slice(0,4));(new TextDecoder).decode(s);let l=new DataView(c);if(l.getUint32(0,!0)==o){l.getUint32(4,!0);let o=l.getUint32(8,!0);var y=t(n.slice(12,o+12));const c=e.enc.Utf8.parse(i),s=e.enc.Utf8.parse(a);var f=e.lib.CipherParams.create({ciphertext:y}),w=r(e.AES.decrypt(f,c,{iv:s,mode:e.mode.CBC,padding:e.pad.ZeroPadding}));let d=new Uint8Array(w),g=new Uint8Array(n.slice(12+o,n.byteLength)),h=new Uint8Array(d.byteLength+g.length);return h.set(d,0),h.set(g,d.length),h}console.error("文件格式错误，请检查")})(y,c,s);if(f){let e=n(f,`${i(a)}.glb`);l(e)}}})).catch((e=>{console.error("enc失败,",e)}))}))}}export{c as SecurityTool};
